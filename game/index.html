<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PUMBAA DOOM 3D | </title>
    
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22></text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;900&display=swap" rel="stylesheet">
    
    <style>
        :root { --amber: #ffb900; --dark: #050505; --red: #ff4b4b; }
        * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; touch-action: none; }
        body { font-family: 'Rubik', sans-serif; background-color: #000; color: white; overflow: hidden; height: 100vh; }

        #game-container { position: relative; width: 100vw; height: 100vh; cursor: crosshair; }
        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

        /*  拽专 转转 (Doom Style) */
        #status-bar {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 100px;
            background: #222; border-top: 4px solid #444;
            display: flex; align-items: center; justify-content: space-around;
            z-index: 50; padding: 0 20px;
        }
        .stat-box { text-align: center; font-weight: 900; }
        .stat-label { font-size: 0.7rem; color: #888; text-transform: uppercase; }
        .stat-value { font-size: 2rem; color: var(--red); }
        #pumbaa-face { font-size: 3.5rem; background: #333; padding: 5px 15px; border-radius: 10px; border: 2px solid #555; }

        /* Minimap */
        #minimap {
            position: absolute; top: 20px; right: 20px; width: 120px; height: 120px;
            background: rgba(0,0,0,0.8); border: 2px solid #555; border-radius: 5px; z-index: 60;
        }

        #msg-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); display: none; flex-direction: column;
            align-items: center; justify-content: center; z-index: 100;
        }
        .btn { padding: 15px 40px; border-radius: 5px; border: none; background: var(--red); color: white; font-weight: 900; font-size: 1.5rem; cursor: pointer; }
    </style>
</head>
<body>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
        <canvas id="minimap"></canvas>

        <div id="status-bar">
            <div class="stat-box">
                <div class="stat-label">拽</div>
                <div class="stat-value" id="score-val">000</div>
            </div>
            <div id="pumbaa-face"></div>
            <div class="stat-box">
                <div class="stat-label">专拽</div>
                <div class="stat-value" id="bugs-val">0</div>
            </div>
        </div>

        <div id="msg-layer">
            <h2 style="font-size: 3rem; color: var(--red); margin-bottom: 20px;">拽 !</h2>
            <p style="margin-bottom: 30px;">爪转 专拽 注 .</p>
            <button class="btn" onclick="nextLevel()">砖 </button>
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const miniCanvas = document.getElementById('minimap');
    const miniCtx = miniCanvas.getContext('2d');

    // --- 专转 注 ---
    const MAP_SIZE = 16;
    const CELL_SIZE = 64;
    let map = [];
    let sprites = []; // 专拽 爪注

    const player = {
        x: 150, y: 150, dir: 0, 
        speed: 0, rotSpeed: 0,
        moveSpeed: 3.5, rotStep: 0.06,
        bob: 0, bobSpeed: 0.15, bobAmount: 8
    };

    let score = 0;
    let bugs = 0;

    // 爪专转 拽住专转 拽专 ( 住 专专)
    const wallTex = document.createElement('canvas');
    wallTex.width = 64; wallTex.height = 64;
    const wCtx = wallTex.getContext('2d');
    wCtx.fillStyle = '#4a2c0a'; wCtx.fillRect(0,0,64,64);
    wCtx.strokeStyle = '#2a1805';
    for(let i=0; i<4; i++) {
        wCtx.strokeRect(0, i*16, 32, 16);
        wCtx.strokeRect(32, i*16+8, 32, 16);
    }

    function generateMap() {
        map = Array(MAP_SIZE).fill().map(() => Array(MAP_SIZE).fill(1));
        function walk(x, y) {
            map[y][x] = 0;
            const dirs = [[0,1],[0,-1],[1,0],[-1,0]].sort(() => Math.random() - 0.5);
            for(let [dx, dy] of dirs) {
                let nx = x + dx*2, ny = y + dy*2;
                if(nx > 0 && nx < MAP_SIZE-1 && ny > 0 && ny < MAP_SIZE-1 && map[ny][nx] === 1) {
                    map[y+dy][x+dx] = 0;
                    walk(nx, ny);
                }
            }
        }
        walk(1, 1);
        spawnBugs();
    }

    function spawnBugs() {
        sprites = [];
        for(let i=0; i<3; i++) {
            let sx, sy;
            do { sx = Math.floor(Math.random()*MAP_SIZE); sy = Math.floor(Math.random()*MAP_SIZE); } 
            while(map[sy][sx] !== 0);
            sprites.push({ x: sx*CELL_SIZE+32, y: sy*CELL_SIZE+32, char: '', collected: false });
        }
    }

    function resize() {
        canvas.width = window.innerWidth / 2; // 专爪  住 专专
        canvas.height = (window.innerHeight - 100) / 2;
        miniCanvas.width = 120; miniCanvas.height = 120;
    }

    function drawMinimap() {
        const s = 120 / MAP_SIZE;
        miniCtx.fillStyle = '#000'; miniCtx.fillRect(0,0,120,120);
        for(let y=0; y<MAP_SIZE; y++) {
            for(let x=0; x<MAP_SIZE; x++) {
                if(map[y][x]) { miniCtx.fillStyle = '#555'; miniCtx.fillRect(x*s, y*s, s, s); }
            }
        }
        miniCtx.fillStyle = 'red';
        miniCtx.fillRect((player.x/CELL_SIZE)*s-2, (player.y/CELL_SIZE)*s-2, 4, 4);
    }

    function render() {
        // 砖 专爪驻
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0, 0, canvas.width, canvas.height/2);
        ctx.fillStyle = '#333'; ctx.fillRect(0, canvas.height/2, canvas.width, canvas.height/2);

        const zBuffer = [];

        // Raycasting
        for(let i=0; i<canvas.width; i++) {
            let rayAngle = (player.dir - 0.5) + (i / canvas.width);
            let distance = 0;
            let x = player.x, y = player.y;
            let cos = Math.cos(rayAngle), sin = Math.sin(rayAngle);

            while(distance < 800) {
                x += cos * 2; y += sin * 2; distance += 2;
                if(map[Math.floor(y/CELL_SIZE)][Math.floor(x/CELL_SIZE)]) break;
            }

            zBuffer[i] = distance;
            let fixDist = distance * Math.cos(rayAngle - player.dir);
            let h = (CELL_SIZE * canvas.height) / fixDist;
            
            // 爪专 拽专 注 爪
            let shade = Math.min(255, 20000 / (distance * 1.5));
            ctx.globalAlpha = shade / 255;
            ctx.drawImage(wallTex, (x+y)%64, 0, 1, 64, i, (canvas.height/2 - h/2) + player.bob, 1, h);
            ctx.globalAlpha = 1;
        }

        // 专专 住驻专 (专拽)
        sprites.forEach(s => {
            if(s.collected) return;
            let dx = s.x - player.x, dy = s.y - player.y;
            let dist = Math.sqrt(dx*dx + dy*dy);
            let angle = Math.atan2(dy, dx) - player.dir;
            if(angle < -Math.PI) angle += Math.PI*2;
            if(angle > Math.PI) angle -= Math.PI*2;

            if(Math.abs(angle) < 1) {
                let x = (0.5 * (angle / 0.5) + 0.5) * canvas.width;
                let h = (CELL_SIZE * canvas.height) / dist;
                if(dist < zBuffer[Math.floor(x)]) {
                    ctx.font = `${h}px serif`;
                    ctx.textAlign = 'center';
                    ctx.fillText(s.char, x, (canvas.height/2 + h/3) + player.bob);
                }
            }
            // 住祝
            if(dist < 30) { s.collected = true; bugs++; score += 500; updateUI(); checkWin(); }
        });
    }

    function updateUI() {
        document.getElementById('score-val').innerText = score.toString().padStart(3, '0');
        document.getElementById('bugs-val').innerText = bugs;
        const face = document.getElementById('pumbaa-face');
        face.innerText = ''; setTimeout(() => face.innerText = '', 500);
    }

    function checkWin() {
        if(sprites.every(s => s.collected)) {
            document.getElementById('msg-layer').style.display = 'flex';
        }
    }

    function nextLevel() {
        document.getElementById('msg-layer').style.display = 'none';
        generateMap();
        player.x = 100; player.y = 100;
    }

    function loop() {
        // 转注
        let nx = player.x + Math.cos(player.dir) * player.speed;
        let ny = player.y + Math.sin(player.dir) * player.speed;
        if(map[Math.floor(ny/CELL_SIZE)][Math.floor(nx/CELL_SIZE)] === 0) {
            player.x = nx; player.y = ny;
        }
        player.dir += player.rotSpeed;

        // 驻拽  (Bobbing)
        if(player.speed !== 0) {
            player.bob = Math.sin(Date.now() * player.bobSpeed) * player.bobAmount;
        } else {
            player.bob *= 0.9;
        }

        render();
        drawMinimap();
        requestAnimationFrame(loop);
    }

    // 砖
    window.addEventListener('keydown', e => {
        if(e.key === 'w' || e.key === 'ArrowUp') player.speed = player.moveSpeed;
        if(e.key === 's' || e.key === 'ArrowDown') player.speed = -player.moveSpeed;
        if(e.key === 'a' || e.key === 'ArrowLeft') player.rotSpeed = -player.rotStep;
        if(e.key === 'd' || e.key === 'ArrowRight') player.rotSpeed = player.rotStep;
    });
    window.addEventListener('keyup', e => {
        if(['w','s','ArrowUp','ArrowDown'].includes(e.key)) player.speed = 0;
        if(['a','d','ArrowLeft','ArrowRight'].includes(e.key)) player.rotSpeed = 0;
    });

    // 转 抓'
    window.addEventListener('touchstart', e => {
        const x = e.touches[0].clientX;
        if(x < window.innerWidth/3) player.rotSpeed = -player.rotStep;
        else if(x > window.innerWidth*0.6) player.rotSpeed = player.rotStep;
        else player.speed = player.moveSpeed;
    });
    window.addEventListener('touchend', () => { player.speed = 0; player.rotSpeed = 0; });

    window.addEventListener('resize', resize);
    resize();
    generateMap();
    loop();
</script>
</body>
</html>
